import java_cup.runtime.*;

/* Terminals (tokens returned by the scanner). */

terminal 				AND, OR, NOT;
terminal 				NOTEQ, EQEQ, LT, LTE, GT, GTE;
terminal				EQ, PLUS, MINUS, MULTI;
terminal				LBRACK, RBRACK, LPAREN, RPAREN, LBRACE, RBRACE;
terminal				INT, CHAR, BOOL;
terminal				IF, ELSE, WHILE, NEW, FREE, PRINT;
terminal				SEMICOLON, COMMA;
terminal				MAIN, RETURN;

terminal Integer		INTEGER_LITERAL;
terminal Character		CHARACTER_LITERAL;
terminal Boolean		BOOLEAN_LITERAL;
terminal String			IDENTIFIER;

/* Non-terminals */

nonterminal 			program;
nonterminal				main_function;
nonterminal				function_declaration_list;
nonterminal				function_declaration;
nonterminal				function_definition_list;
nonterminal				function_definition;
nonterminal				function_signature;
nonterminal				formals;
nonterminal				parameter_list;
nonterminal				parameter;
nonterminal				function_body;
nonterminal				variable_declaration_list;
nonterminal				variable_declaration;
nonterminal				statement;
nonterminal				statements;
nonterminal				statement_list;
nonterminal				expression;
nonterminal				args;
nonterminal				expression_list;
nonterminal				type;
nonterminal				signature_type;
nonterminal				primitive_type;
nonterminal				stack_array;
nonterminal				heap_array;

/* Precedences */

precedence left			LBRACK, RBRACK;
precedence right 		NOT;
precedence left 		MULTI;
precedence left 		PLUS, MINUS;
precedence left 		LT, LTE, GT, GTE;
precedence left 		EQEQ, NOTEQ;
precedence left 		AND;
precedence left 		OR;

/* Grammar */

start with program;

/* Problem: 	Parser doesn't know if INT starts the main function or a declaration with just - "function_declaration_list main_function function_definition_list"
 * Solution:	Must include main function so it's just a question of rearraging productions, see ans: https://stackoverflow.com/questions/25185601/shift-reduce-error-with-cup
 * 				(Now lookahead can see if it is "main" or an IDENTIFIER after shifting an INT).
 */

program 					::= function_declaration_list:decls main_function:main function_definition_list:defs    {: RESULT = new Program(decls, main, defs); :}
								| main_function:main                                                                {: RESULT = new Program(main); :}
								;

main_function				::= INT MAIN LPAREN INT IDENTIFIER:argc COMMA CHAR LBRACK RBRACK LBRACK RBRACK
                                IDENTIFIER:argv RPAREN LBRACE function_body:body RBRACE                             {: RESULT = new Main(argc, argv, body); :};

/* Note: 		Left recursion for "lists" in a LR parser uses less parser stack so it is preferable. */

function_declaration_list	::= function_declaration_list:decls function_declaration:decl                           {: decls.add(decl); RESULT = decl; :}
								| function_declaration:decl                                                         {: LinkedList<FunctionDeclaration> list = new LinkedList<>();
								                                                                                        list.add(decl);
								                                                                                        RESULT = list; :}
								;
								
function_declaration 		::= function_signature:sgnt SEMICOLON                                                   {: RESULT = new FunctionDeclaration(sgnt); :};
						
function_definition_list	::=	function_definition_list:defs function_definition:def                               {: defs.add(def); RESULT = defs; :}
								| function_definition:def                                                           {: LinkedList<FunctionDefinition> list = new LinkedList<>();
								                                                                                        list.add(def);
                                                                                                                        RESULT = new LinkedList<FunctionDefinition>(); :}
								;
	
function_definition			::= function_signature:sgnt LBRACE function_body:body RBRACE                            {: RESULT = new FunctionDefintion(sgnt, body); :};

function_signature			::= signature_type:type IDENTIFIER:name LPAREN formals:args RPAREN                      {: RESULT = new FunctionSignature(type, name, args); :};

formals 					::= parameter_list:params                                                               {: RESULT = params; :}
								|                                                                                   {: RESULT = new LinkedList<Parameter>(); :}
								;

parameter_list				::= parameter_list:params COMMA parameter:param                                         {: params.add(param); RESULT = params; :}
								| parameter:param                                                                   {: LinkedList<Parameter> list = new LinkedList<>();
								                                                                                        list.add(param);
								                                                                                        RESULT = list; :}
								;
			
parameter 					::= signature_type:type IDENTIFIER:id                                                   {: RESULT = new Parameter(type, id); :};

function_body				::= variable_declaration_list:vars statements:stms RETURN expression:ret SEMICOLON      {: RESULT = new FunctionBody(vars, stms, ret); :};

variable_declaration		::= type:type IDENTIFIER:id SEMICOLON                                                   {: RESULT = new VariableDeclaration(type, id); :};

variable_declaration_list	::= variable_declaration_list:vars variable_declaration:var                             {: vars.add(var); RESULT = vars; :}
								|                                                                                   {: RESULT = new LinkedList<FunctionDefinition>(); :}
								;

statement					::= LBRACE statement_list:stms RBRACE                                                   {: RESULT = new Statement.Compound(stms); :}
								| IF LPAREN expression:cond RPAREN statement:then ELSE statement:els                {: RESULT = new Statement.IfThenElse(cond, then, els); :}
								| WHILE LPAREN expression:cond RPAREN statement:body                                {: RESULT = new Statement.While(cond, body); :}
								| IDENTIFIER:id EQ expression:val SEMICOLON                                         {: RESULT = new Statement.Assign(id, val); :}
								| IDENTIFIER:id LBRACK expression:idx RBRACK EQ expression:val SEMICOLON            {: RESULT = new Statement.ArrayAssign(id, idx, val); :}
								| FREE IDENTIFIER:id SEMICOLON                                                      {: RESULT = new Statement.Free(id); :}
								| PRINT LPAREN expression:val RPAREN SEMICOLON                                      {: RESULT = new Statement.Print(val); :}
								;

statements                  ::= statement_list:stms                                                                 {: RESULT = stms; :}
                                |                                                                                   {: RESULT = new LinkedList<Statement>(); :}
                                ;

statement_list				::= statement_list:stms statement:stm                                                   {: stms.add(stm); RESULT = stms; :}
								| statement:stm                                                                     {: LinkedList<Statement> list = new LinkedList<>();
								                                                                                        list.add(stm);
								                                                                                        RESULT = list; :}
								;

expression					::= expression:lhs AND expression:rhs                                                   {: RESULT = new Expression.Logical(sym.AND, lhs, rhs); :}
								| expression:lhs OR expression:rhs                                                  {: RESULT = new Expression.Logical(sym.OR, lhs, rhs); :}
								| expression:lhs NOTEQ expression:rhs                                               {: RESULT = new Expression.Equality(sym.NOT, lhs, rhs); :}
								| expression:lhs EQEQ expression:rhs                                                {: RESULT = new Expression.Equality(sym.EQEQ, rhs); :}
								| expression:lhs LT expression:rhs                                                  {: RESULT = new Expression.Comparison(sym.LT, lhs, rhs); :}
								| expression:lhs LTE expression:rhs                                                 {: RESULT = new Expression.Comparison(sym.LTE, lhs, rhs); :}
								| expression:lhs GT expression:rhs                                                  {: RESULT = new Expression.Comparison(sym.GT, lhs, rhs); :}
								| expression:lhs GTE expression:rhs                                                 {: RESULT = new Expression.Comparison(sym.GTE, lhs, rhs); :}
								| expression:lhs PLUS expression:rhs                                                {: RESULT = new Expression.Arithmetic(sym.PLUS, lhs, rhs); :}
								| expression:lhs MINUS expression:rhs                                               {: RESULT = new Expression.Arithmetic(sym.MINUS, lhs, rhs); :}
								| expression:lhs MULTI expression:rhs                                               {: RESULT = new Expression.Arithmetic(sym.MULTI, rhs); :}
								| expression:arr LBRACK expression:idx RBRACK                                       {: RESULT = new Expression.ArrayAccess(arr, idx); :}
								| IDENTIFIER:name LPAREN args:args RPAREN                                           {: RESULT = new Expression.Call(name, args); :}
								| INTEGER_LITERAL:val                                                               {: RESULT = new Expression.IntLiteral(val); :}
								| CHARACTER_LITERAL:val                                                             {: RESULT = new Expression.CharLiteral(val); :}
								| BOOLEAN_LITERAL:val                                                               {: RESULT = new Expression.BoolLiteral(val); :}
								| IDENTIFIER:id                                                                     {: RESULT = new Expression.Identifier(id); :}
								| NEW INT LBRACK expression:len RBRACK                                              {: RESULT = new Expression.NewArray(sym.INT, len); :}
								| NEW CHAR LBRACK expression:len RBRACK                                             {: RESULT = new Expression.NewArray(sym.CHAR, len); :}
								| NOT expression:exp                                                                {: RESULT = new Expression.Negated(exp); :}
								| LPAREN expression:exp RPAREN                                                      {: RESULT = exp; :}
								;

args						::= expression_list:exps                                                                {: RESULT = exps; :}
								|                                                                                   {: RESULT = new LinkedList<Expression>(); :}
								;

expression_list				::= expression_list:exps COMMA expression:exp                                           {: exps.add(exp); RESULT = exps; :}
								| expression:exp                                                                    {: LinkedList<Expression> list = new LinkedList<>();
								                                                                                        list.add(exp);
								                                                                                        RESULT = list; :}
								;

type						::= stack_array:sarr                                                                    {: :}
								| heap_array:harr
								| primitive_type:prim
								;

signature_type				::= primitive_type:prim
								| heap_array:harr
								;
								
primitive_type				::= INT                                                                                 {: RESULT = new Type.NonArr(sym.INT); :}
								| CHAR
								| BOOL
								;
								
stack_array					::= INT LBRACK INTEGER_LITERAL RBRACK                                                   {: RESULT = new Type.HeapArr(sym.INT); :}
								| CHAR LBRACK INTEGER_LITERAL RBRACK
								;

heap_array					::= INT LBRACK RBRACK
								| CHAR LBRACK RBRACK
								;