\documentclass[a4paper, 12pt]{article}
\usepackage{listings}
\usepackage{syntax}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\pagenumbering{roman}

\title{Interim Report}
\author{Candidate Number: 164597}
\date{November 2019}
\maketitle
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}
	
	\textbf{In brief:} The overall goal of this project is to create a toy compiler for a simple language. This will then be used to run a program to smash the stack, and begin an exploit known as return oriented programming (ROP). 
	
	\newpage
	
	\subsection{Problem Area}
	
		\subsubsection{Buffer Overflow Attacks}
	
			This section covers buffer overflow exploits, which will be the primary vector for beginning a ROP exploit in this project. To first understand the topic, a recap on stack frames in memory is needed.
			\\
			\\
			The figure below shows a simplified view of what a function with one local array variable would look like in memory \cite{AR-layout-x86-64}. One of the key concepts to grasp is that the data for the function that called the current one sits directly higher up in memory.
		
			\begin{figure}[h]
				\centering
				\begin{tabular}{r|c|l}
					&& High Memory Address \\
					\cline{2-2}
					&& \\
					&& \\
					& Prev Function & \\
					&& \\
					&& \\
					\cline{2-2}
					&& \\
					& Incoming Parameters & \\
					&& \\
					\cline{2-2}
					& Return Address & \\
					\cline{2-2}
					& Base Pointer & \\
					\cline{2-2}
					&& \\
					& Local Array & \\
					Start of Array $\rightarrow$ && \\
					\cline{2-2}
					&& Low Memory Address \\
				\end{tabular}
				\label{AR-diagram}
				\caption{General Stack Frame Layout}
			\end{figure}
			
			The return address is crucial to this structure. Its job is to tell the program where to go back to in the previous function after it's done with the current one. Therefore if it is able to be altered, an attacker can essentially tell the program to start doing something else.
			\\
			\\
			Fortunately the return address is accessible with the use of the local array. Since array accesses are encoded by adding to the start of the array, an array access outside the bounds goes higher up in memory than what is usually safe. Therefore by using calculated unsafe array accesses and assignments, the return address can be altered to whatever the attacker wants.
		
		\subsubsection{The NX/XD defense}
		
			Typically, due to the basic fact that instructions are data and vice-versa, the way that simple attacks would work is that before placing the return address, an attacker would write in the code  they want to run. Then they would target the return address back at the sequence that's just been written.
			\\
			\\
			However, this attack type of attack was identified and defended against some time ago. The defense put in place, relies upon the idea that the stack in memory should only be used to store data, not code to be executed. Therefore by putting a flag which disallows execution on certain regions of memory, you can effectively shutdown the attacker being able to write what they want and then execute it. They can only write what they want, not execute it, hence the name No Execute (NX) or Execute Disable (XD) \cite{NX-XD-bit}.
			
\newpage

		\subsubsection{ROP}
	
			ROP is among one of the methods of effectively sidestepping this defense. The core idea behind it and many other such attacks is to execute pre-existing sequences without this NX/XD flag, rather than find a way to turn it off.
			\\
			\\
			However, one of the main challenges in this approach is to find such desirable sequences that an attacker would want to execute. In terms of ROP these sequences are called gadgets and use of them requires a little arranging beforehand. The structure of a gadget is simply a sequence of code that is guaranteed to execute its final instruction, that is the return (``ret'') instruction.
			\\
			\begin{figure}[h]
				\centering
				\begin{tabular}{r|c|l}
					&& High Memory Address \\
					&& \\
					&& \\
					& Earlier Functions & \\
					&& \\
					&& \\
					\cline{2-2}
					& nth Gadget Address & \\
					\cline{2-2}
					& ... & \\
					\cline{2-2}
					& 2nd Gadget Address & \\
					\cline{2-2}
					Previously RA $\rightarrow$ & 1st Gadget Address & \\
					\cline{2-2}
					Previously BP $\rightarrow$ && \\
					& Overwritten & \\
					& By Local Array & \\
					&& \\
					\cline{2-2}
					&& Low Memory Address \\
				\end{tabular}
				\label{ROP-diagram}
				\caption{Example Prepped ROP Stack}
			\end{figure}
			\\
			The return instruction pulls an address off the stack and starts executing other instructions from there. Therefore, if several addresses are placed consecutively in memory as shown above, and since all the gadgets end in ``ret'', what will end up happening is the body of the gadgets will run one after the other with the ``ret'' chaining them together. Each ``ret'' at the end of the gadget will pull the next address of the stack, and start the whole process again from there. Because the gadget bodies are also executed, through careful arrangement this allows arbitrary code execution to be performed.
	
		\subsubsection{Components of a Toy Compiler}
		
			This section will be giving a short overview of the components necessary to implement the compiler for the language given in~\ref{sec:grammar}.
			\\
			\\
			\textbf{The Lexer:}
			\\
			\\
			The job of the lexer is simply to tokenise the input. The computer sees code as a long list of characters e.g. [ `i', `n', `t', ` `, `x', `=' ]. As one would imagine this is rather inconvenient to work with. So, to tokenise is to take this list of characters and produce a list of corresponding tokens a.k.a. words with the useless information removed i.e. whitespace and comments. The tokenised version of above is therefore [ INT, x, EQ ].
			\\
			\\
			\textbf{The Parser:}
			\\
			\\
			The job of the parser is to take the tokens given from the lexer, and produce an easy to work with structure that captures the essence of the program that was written. There are several parser tools available that take a grammar not too dissimilar from~\ref{sec:grammar} and automate this process. In this project the Java CUP parser [ref needed] is one such tool that will be used. 
			% Perhaps expand by showing the tree diagram
			\\
			\\
			\textbf{The Type Checker:}
			\\
			\\
			Essentially the job of the type checker is to catch any semantic errors in the program structure that was given by the parser. For example the programmer might try to assign True to a variable that holds an integer. Obviously for safety reasons the code should not move past this phase. The way this will be accomplished is through the use of a common design pattern known as the Visitor pattern [ref needed].  
			\\
			\\
			\textbf{The Code Generator:}
			\\
			\\
			% Perhaps talk about IRs 
			Finally and perhaps the most self explanatory phase is code generation. The code generator can operate on the same structure after type checking is successful, and produces correct machine code that is able to be run directly on the computer. A point to note is that as this is a toy compiler no optimisations of such code will be attempted in this project.

	\subsection{Aims}

		One of the primary aims of this project will be to implement a compiler for the language given in section~\ref{sec:grammar}. This language is a modified subset of the C language that contains only the bare bones needed to perform the buffer overflow exploit that begins ROPing.
		\\
		\\
		An additional aim for this project will be to target the x86-64 assembly language for the compiler output. This architecture is chosen since it is the easiest to perform ROP exploits on. This is due to the fact that boundaries on instruction sizes aren't enforced like they are in other architectures such as MIPS [ref needed].
		\\
		\\
		A final aim for this project is to target the exploit to run on a virtualised Linux distro. Initially this distro will have other defenses such as ASLR (not mentioned in this report)  disabled, but as the project progresses the aim is to ultimately run the ROP exploit with the defenses in place. However, this is relegated to the extensions phase of the project.
		
\newpage

	\subsection{Objectives}
	
		A primary objective of this project is to first develop a front end that is a Lexer and Parser for the language given in~\ref{sec:grammar}. This will be done using the lexer generator JFlex coupled with the Java CUP parser generator. 
		\\
		\\
		Along a similar vein another primary objective of this project will then be to implement the type checking and code generation phases. The language of choice for this will be Scala. 
		\\
		\\ 
		Given the implemented compiler, the next primary objective is to then write a program in the language that will perform the buffer overflow exploit. With this initial vector the objective is to then get the ROP exploit running by first manually inserting the gadget code into the program at the low level.
		\\
		\\
		If there's time left within the project a few secondary objectives will be explored. For example:
		\begin{enumerate}
			\item Removing the crutch of manually inserting gadgets and instead finding them by searching through libraries using the Galileo algorithm [ref needed].
			\item Automating the process of making Gadget chains by implementing a Gadget compiler. See related work [ref needed].
			\item Defeating the ASLR defense to get the exploit to run consistently without it disabled. [ref needed]
			\item Implementing a run-time monitor using Intel program statistics to detect when ROP attacks are occurring.
		\end{enumerate}

\newpage

	\subsection{Motivations}
	
		The motivation for choosing Scala is down to a couple reasons. First and foremost, it will be a challenge to learn and build a project in a new language. Secondly, Scala interfaces with Java allowing use of tools previously mentioned such as the Java CUP parser.  
	\\
	\\
		The motive for building a compiler from scratch rather than performing the exploit in a pre-existing language is likewise for two reasons. Firstly, in creating my own compiler it allows a greater deal of control at the low level than what is normally available. Additionally, building a compiler adds complexity to what would otherwise be a shorter and less complex project.

	\subsection{Project Relevance} 
	
		Essentially this project not only builds upon the Compilers course from last year, but also somewhat ties into the current Computer Security module. This project will also demonstrate my proficiency in areas such as compiler design and knowledge of exploits.

\newpage

\section{Software Engineering Considerations} 

	It goes without saying that a private GitHub repository will be used to track changes and commits through out this project. That aside, in terms of testing the compilation output for correctness, this will be done in an emulated x86-64 environment such as: \url{https://www.unicorn-engine.org/} . Essentially an oracle style of testing will be used, wherein pre-computed results of equivalent programs written in other languages will be compared with the actual output of my language in the emulator.  
\\
\\
	For the actual live testing of the buffer overflow and ROP exploits, as previously mentioned that will be done on a virtual Linux image using any of the major virtualization providers e.g. \url{https://www.virtualbox.org/}
\\
\\
	With regard to self evaluation of the project's success/ quality, there are a few key metrics that will be used. First of all, the correctness of the compiled output and the type checker matters a great deal. Secondly, the amount of crutches needed to execute the ROP exploit will also weigh heavy. Finally, whether extensions on the project are completed will also be taken into consideration in my evaluation.

\newpage

\section{Professional and Ethical Considerations}

	This project although will provide explanations of how buffer overflow and ROP exploits work, will not be about finding a live vulnerability in a real program. The exploit will be performed within my own privileged program on a virtualised instance, therefore about demonstrating knowledge of how these attacks work and how they would be carried out in practice.
	\\
	\\
	With the use of an actual live exploit, I believe to remain ethical would require one of two things. Either, proper fore-disclosure to the affected company some time before the final release of my report in order so that they can patch it. Alternatively, purposely using an older version of some software that already has the vulnerability patched. However, even the former in my belief is still questionable as there may be some users that are still using the version. To re-iterate this project is not about either. Additionally, searching out for such vulnerabilities would be in my opinion violating point 2.1/2.2 of the BCS code of conduct as I believe it is beyond my current capabilities [ref needed].
	\\
	\\
	A final point to note about this project is that there are no intended users, neither are there any human participants. Therefore ethical review before such interactions and subsequently interviews is not necessary as there will be none within this project. Even the language developed will not have any other programmer testing other than myself.

\newpage

\section{Requirements Analysis}

% Ideal solution will be producing correct code
% Ideal function that will be performed is opening a root shell
% This project will not be about finding an actual initial vector for ROPing.
% What must be achieved is the time frame is given by the primary objectives, the actual compiler implementation, a buffer overflow into inserted gadget ROPing.

	\subsection{Non-Functional Requirements}
	
	% Must be written in Scala using Intellij IDE
	% Must use the CUP parser and JFlex
	
	\subsection{Functional Requirements}
	
	% Compiler must be correct
	% No IR will be used, simply using the AST is good enough
	% Compiler will be using a simple register allocation scheme that targets a Register machine and shifts to an Accumulator strategy.

\newpage

\section{Related Work}

% Original paper
% ROP compiler github (more like a rop assembler) will be attempting something like this in extension if possible
% How mine contributes:
% Extension of ROP detection could help combat this attack
% Extension of Gadget Compiler could help building such attacks

\newpage

\section{Appendix}

\newpage

\subsection{EBNF Grammar} \label{sec:grammar}
\textbf{Main things to note:} 
\begin{enumerate}
\item This language may be subject to slight changes as the project progresses, but the version given here symbolises the core of the language.
\item This language explicitly differentiates between arrays on the stack and ones on the heap.
\item The new and free keywords break from C convention so as not to mislead about malloc usage.
\item This language has the idiom declarations before definitions baked in. This is done for ease of type checking.
\item The precedence of operators is follows those in regular C.
\end{enumerate}
\textbf{Language:} 
\begin{grammar}
<Goal> ::= <FunctionDeclaration>* <MainFunction> <FunctionDefinition>*

<FunctionSignature> ::= <SignatureType> <Identifier> `(' (<SignatureType> <Identifier> (`,' <SignatureType> <Identifier>)*)? `)'

<FunctionDeclaration> ::= <FunctionSignature> `;'

<FunctionDefinition> ::= <FunctionSignature> `\{' <FunctionBody> `\}'

<FunctionBody> ::= <VarDeclaration>* <Statement>* `return' <Expression> `;'

<MainFunction> ::= `int' `main' `(' `int' <Identifier> `,' `char' `[' `]' `[' `]' <Identifier> `)' `\{' <FunctionBody> `\}'

<VarDeclaration> ::= <Type> <Identifier> `;'

<Type> ::= <StackArray> 
\alt <HeapArray> 
\alt <PrimitiveType>

<SignatureType> ::= <PrimitiveType>
\alt <HeapArray>

<PrimitiveType> ::= `int'
\alt `char'
\alt `boolean'

<StackArray> ::= `int' `[' <IntegerLiteral> `]'
\alt `char' `[' <IntegerLiteral> `]' 

<HeapArray> ::= `int' `[' `]'
\alt `char' `[' `]' 

<Statement> ::= `\{' <Statement>* `\}'
\alt `if' `(' <Expression> `)' <Statement> `else' <Statement>
\alt `while' `(' <Expression> `)' <Statement>
\alt <Identifier> `=' <Expression> `;'
\alt <Identifier> `[' <Expression> `]' `=' <Expression> `;'
\alt `free' <Identifier> `;'
\alt `print' `(' <Expression> `)' `;'

<Expression> ::= <Expression> (`\&\&' | `||' | `!=' | `==' | `<' | `<=' | `>' | `>=' | `+' | `-' | `*') <Expression>
\alt <Expression> `[' <Expression> `]'
\alt <Identifier>  `(' (<Expression> (`,' <Expression>)*)? `)'
\alt <IntegerLiteral>
\alt <CharacterLiteral>
\alt <BooleanLiteral>
\alt <Identifier>
\alt `new' `int' `[' <Expression> `]'
\alt `new' `char' `[' <Expression> `]'
\alt `!' <Expression>
\alt `(' <Expression> `)'
\end{grammar}
\newpage

\subsection{Example Program}
\lstinputlisting{Factorial.rop}
\newpage

\subsection{Project Plan}

\subsection{Interim Logs}

\subsection{Proposal}

\subsection{Word Count: }

\newpage
\bibliographystyle{plain}
\bibliography{InterimReport}

\end{document}