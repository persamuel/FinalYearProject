\documentclass[a4paper, 12pt]{article}
\usepackage{listings}
\usepackage{syntax}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\pagenumbering{roman}

\title{Interim Report}
\author{Candidate Number: 164597}
\date{November 2019}
\maketitle
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}

\textbf{In brief:} The overall goal of this project is to create a toy compiler for a simple language. Which will then be used to run some code to smash the stack, and begin an exploit known as return oriented programming (ROP). 
\\
\\
\textbf{Note:} There are no intended users for this project, all the work produced is meant to be private i.e. for external evaluation and my eyes only.

\subsection{Brief Introduction to the Problem Area}

\subsubsection{Buffer Overflow Attacks}

This section covers buffer overflow exploits, which will be the primary vector for beginning a ROP exploit in this project. To first understand the topic, a recap on stack frames in memory is needed.
\\
\\
The figure below shows a simplified view of what a function with one local array variable would look like in memory \cite{AR-layout-x86-64}. One of the key concepts to grasp is that the data for function that called the current one sits directly higher up in memory.

\begin{figure}[h]
\centering
\begin{tabular}{r|c|l}
&& High Memory Address \\
\cline{2-2}
&& \\
&& \\
& Prev Function & \\
&& \\
&& \\
\cline{2-2}
&& \\
& Incoming Parameters & \\
&& \\
\cline{2-2}
& Return Address & \\
\cline{2-2}
& Base Pointer & \\
\cline{2-2}
&& \\
& Local Array & \\
Start of Array $\rightarrow$ && \\
\cline{2-2}
&& Low Memory Address \\
\end{tabular}
\label{AR-diagram}
\caption{General Stack Frame Layout}
\end{figure}
\newpage
The return address is crucial to this structure. Its job is to tell the program where to go back to in the previous function after it's done in the current one. Therefore if it is able to be altered, an attacker can essentially tell the program to start doing something else.
\\
\\
Fortunately the return address is accessible with the use of the local array. Since array accesses are encoded by adding to the start of the array, an array access outside the bounds goes higher up in memory than what is usually safe. Therefore by using calculated unsafe array accesses and assignments, the return address can be altered to whatever the attacker wants.

\subsubsection{The NX/XD defense}

Typically due to the basic fact that instructions are data and vice-versa. The way that simple attacks would work is that before placing the return address, an attacker would write in the code  they want to run. Then target the return address back at this sequence that's just been written.
\\
\\
However, this attack type of attack was realised and fairly easily defended against. The defense put in place relies upon the idea that the stack in memory should only be used to store data, not code to be executed. Therefore by putting a flag which disallows execution on certain regions of memory, you can effectively shutdown the attacker being able to write what they want then execute it. They can only write what they want, not execute it, hence the name No Execute (NX) or Execute Disable (XD) \cite{NX-XD-bit}.
\newpage
\subsubsection{ROP}

ROP is among one of the methods of effectively sidestepping this defense. The core idea behind it and many other such attacks is to execute pre-existing sequences without this NX/XD flag, rather than find a way to turn it off.
\\
\\
However, one of the main challenges in this approach is to find such desirable sequences that an attacker would want to execute. In terms of ROP these sequences are called gadgets and use of them requires a little arranging beforehand. The structure of a gadget is simply a sequence of code that is guaranteed to execute its final instruction, that is the return (``ret'') instruction.
\\
\begin{figure}[h]
\centering
\begin{tabular}{r|c|l}
&& High Memory Address \\
&& \\
&& \\
& Earlier Functions & \\
&& \\
&& \\
\cline{2-2}
& nth Gadget Address & \\
\cline{2-2}
& ... & \\
\cline{2-2}
& 2nd Gadget Address & \\
\cline{2-2}
Previously RA $\rightarrow$ & 1st Gadget Address & \\
\cline{2-2}
Previously BP $\rightarrow$ && \\
& Overwritten & \\
& By Local Array & \\
Start of Array $\rightarrow$ && \\
\cline{2-2}
&& Low Memory Address \\
\end{tabular}
\label{ROP-diagram}
\caption{Example Prepped ROP Stack}
\end{figure}
\\
What ``ret'' does, is it pulls an address off the stack and starts executing the instructions from there. Therefore, if several addresses are placed consecutively in memory like what is shown above. Since all the gadgets end in ``ret'', what will end up happening is the body of the gadgets will run one after the other with the ``ret'' chaining them together. Each ``ret'' at the end of the gadget will pull the next address of the stack, and start the whole process again from there. Because the gadget bodies are also executed, through careful arrangement this allows arbitrary code execution to be performed.

\subsubsection{Components of a Toy Compiler}

This section will be giving a short overview of the components necessary to implement the compiler for the language given in~\ref{sec:grammar}.
\\
\\
\textbf{The Lexer:}
\\
\\
The job of the lexer is simply to tokenise the input. The computer sees code as a long list of characters e.g. [ `i', `n', `t', ` `, `x', `=' ]. As one would imagine this is rather inconvenient to work with. So to tokenise is to take this list of characters and produce a list of corresponding tokens with the useless info removed i.e. whitespace and comments. A tokenise example from above is as such [ INT, x, EQ ].
\\
\\
\textbf{The Parser:}
\\
\\
The job of the parser is to take the tokens given from the lexer, and produce an easy to work with structure that captures the essence of the program that was written. There are several parser tools available that take a grammar not too dissimilar from~\ref{sec:grammar} and automate this process. In this project the Java CUP parser [ref needed] is one such tool that will be used. 
\\
\\
\textbf{The Type Checker:}
\\
\\
Essentially the job of the type checker is to catch all semantic errors in the program structure (given by the parser) that may have been made. For example the programmer might try to assign True to a variable that holds an integer. Obviously for safety reasons the code should not move past this phase. The way this will be accomplished is through the use of a common design pattern known as the Visitor pattern [ref needed].  
\\
\\
\textbf{The Code Generator:}
\\
\\
Finally and perhaps the most self explanatory phase is code generation. The code generator operates on the same structure after type checking is successful, and produces correct machine code that is able to be run directly on the computer. A point to note is that as this is a toy compiler no optimisations of such code will be attempted in this project.

\subsection{Aims}

One of the primary aims of this project will be to implement a compiler for the language given in section~\ref{sec:grammar}. This language is a modified subset of the C language, that contains only the bare bones needed to perform the buffer overflow exploit to begin ROPing.
\\
\\
An additional aim for this project will be to target the x86-64 assembly language for the compiler output. This architecture is chosen since it is the easiest to perform ROP exploits on. This is due to the fact that boundaries on instruction sizes aren't enforce like they are in other architectures such as MIPS.
\\
\\
A final aim for this project is to target the exploit to run on a virtualised Linux distro. Initially this distro will have other defenses such as ASLR (not mentioned in this report)  disabled, but as the project progresses the aim is to ultimately run the ROP exploit with the defenses in place. However, this is relegated to the extensions phase of the project as one of the first to be attempted.

\subsection{Objectives}

% build compiler in scala using JFlex and CUP for front-end
% smash stack using strcpy function written in my language
% start off by manually inserting the gadgets nessecary
% extend by building galileo algorithm and roping off found gadgets 

\subsection{Motivation}

% Compilers are hard things and it adds extra difficulty to project that otherwise would be simple
% Building my own compiler allows greater control of the low level

\subsection{Project Relevance} % Why is it important

% 

\section{Software Engineering Considerations} 

% Using Github to track progress
% Running compiled code in an emulated x86-64 enviroment e.g. https://www.unicorn-engine.org/ which will allow for testing of my languages correctness 
% Essentially Oracle style testing of precomputing results of several programs and comparing actual output
% Running exploit in a virtual machine.

\section{Professional and Ethical Considerations}

% This project potentially could be used to help exploit systems. Reinforces idea that there should be no users.
% Extension may include a runtime monitor for detecting this 
% No human participants.

\section{Requirements Analysis}

\subsubsection{Non-Functional Requirements}

\subsubsection{Functional Requirements}

\subsubsection{Domain Requirements}

\section{Related Work}

% Original paper
% ROP compiler github (more like a rop assembler) will be attempting something like this in extension if possible
% How mine contributes:
% Extension of ROP detection could help combat this attack
% Extension of Gadget Compiler could help building such attacks

\newpage

\section{Appendix}

\subsection{Project Plan}

\newpage

\subsection{EBNF Grammar} \label{sec:grammar}
\textbf{Main things to note:} 
\begin{enumerate}
\item This language explicitly differentiates between arrays on the stack and ones on the heap.
\item The new and free keywords break from C convention so as not to mislead about malloc usage.
\item This language has the idiom declarations before definitions baked in. This is done for ease of type checking.
\item The precedence of operators is follows those in regular C.
\end{enumerate}
\textbf{Language:} 
\begin{grammar}
<Goal> ::= <FunctionDeclaration>* <MainFunction> <FunctionDefinition>*

<FunctionSignature> ::= <SignatureType> <Identifier> `(' (<SignatureType> <Identifier> (`,' <SignatureType> <Identifier>)*)? `)'

<FunctionDeclaration> ::= <FunctionSignature> `;'

<FunctionDefinition> ::= <FunctionSignature> `\{' <FunctionBody> `\}'

<FunctionBody> ::= <VarDeclaration>* <Statement>* `return' <Expression> `;'

<MainFunction> ::= `int' `main' `(' `int' <Identifier> `,' `char' `[' `]' `[' `]' <Identifier> `)' `\{' <FunctionBody> `\}'

<VarDeclaration> ::= <Type> <Identifier> `;'

<Type> ::= <StackArray> 
\alt <HeapArray> 
\alt <PrimitiveType>

<SignatureType> ::= <PrimitiveType>
\alt <HeapArray>

<PrimitiveType> ::= `int'
\alt `char'
\alt `boolean'

<StackArray> ::= `int' `[' <IntegerLiteral> `]'
\alt `char' `[' <IntegerLiteral> `]' 

<HeapArray> ::= `int' `[' `]'
\alt `char' `[' `]' 

<Statement> ::= `\{' <Statement>* `\}'
\alt `if' `(' <Expression> `)' <Statement> `else' <Statement>
\alt `while' `(' <Expression> `)' <Statement>
\alt <Identifier> `=' <Expression> `;'
\alt <Identifier> `[' <Expression> `]' `=' <Expression> `;'
\alt `free' <Identifier> `;'
\alt `print' `(' <Expression> `)' `;'

<Expression> ::= <Expression> (`\&\&' | `||' | `!=' | `==' | `<' | `<=' | `>' | `>=' | `+' | `-' | `*') <Expression>
\alt <Expression> `[' <Expression> `]'
\alt <Identifier>  `(' (<Expression> (`,' <Expression>)*)? `)'
\alt <IntegerLiteral>
\alt <CharacterLiteral>
\alt <BooleanLiteral>
\alt <Identifier>
\alt `new' `int' `[' <Expression> `]'
\alt `new' `char' `[' <Expression> `]'
\alt `!' <Expression>
\alt `(' <Expression> `)'
\end{grammar}
\newpage

\subsection{Example Program}
\lstinputlisting{Factorial.rop}
\newpage

\subsection{Proposal}

\newpage
\bibliographystyle{plain}
\bibliography{InterimReport}

\end{document}