\documentclass[a4paper, 12pt]{article}
\usepackage{listings}
\usepackage{syntax}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\pagenumbering{roman}

\title{Interim Report}
\author{Candidate Number: 164597}
\date{November 2019}
\maketitle
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}

\textbf{In brief:} The overall goal of this project is to create a toy compiler for a simple language. Which will then be used to run some code to smash the stack, and begin an exploit known as return oriented programming (ROP). 
\\
\\
\textbf{Note:} There are no intended users for this project, all the work produced is meant to be private i.e. for external evaluation and my eyes only.

\subsection{Brief Introduction to the Problem Area}

\subsubsection{Buffer Overflow Attacks}
This section covers buffer overflow exploits, which will be the primary vector for beginning a ROP exploit in this project. To first understand the topic, a recap on stack frames in memory is needed.
\\
\\
The figure below shows a simplified view\cite{AR-layout-x86-64} of what a function with one local array variable would look like in memory. One of the key concepts to grasp is that the function that called the current one sits directly higher up in memory.

\begin{figure}[h]
\centering
\begin{tabular}{r|c|l}
&& High Memory Address \\
\cline{2-2}
&& \\
&& \\
& Prev Function & \\
&& \\
&& \\
\cline{2-2}
&& \\
& Incoming Parameters & \\
&& \\
\cline{2-2}
& Return Address & \\
\cline{2-2}
& Base Pointer & \\
\cline{2-2}
&& \\
& Local Array & \\
Start of Array $\rightarrow$ && \\
\cline{2-2}
&& Low Memory Address \\
\end{tabular}
\label{AR-diagram}
\caption{General Stack Frame Layout}
\end{figure}
The return address is crucial to this structure. Its job is to tell the program where to go back to in the previous function after it's done in the current one. Therefore if it is able to be altered, an attacker can essentially to tell the program to start doing something else.

\subsubsection{NX defense}

\subsubsection{ROP}
hello
\begin{figure}[h]
\centering
\begin{tabular}{r|c|l}
&& High Memory Address \\
&& \\
&& \\
& Earlier Functions & \\
&& \\
&& \\
\cline{2-2}
& nth Gadget Address & \\
\cline{2-2}
& ... & \\
\cline{2-2}
& 2nd Gadget Address & \\
\cline{2-2}
Previously RA $\rightarrow$ & 1st Gadget Address & \\
\cline{2-2}
Previously BP $\rightarrow$ && \\
& Overwritten & \\
& By Local Array & \\
Start of Array $\rightarrow$ && \\
\cline{2-2}
&& Low Memory Address \\
\end{tabular}
\label{ROP-diagram}
\caption{}
\end{figure}

\subsubsection{To-do Summary}

% build compiler in scala using JFlex and CUP for front-end
% smash stack using strcpy function written in my language
% start off by manually inserting the gadgets nessecary
% extend by building galileo algorithm and roping off found gadgets 

\subsubsection{Software Engineering Considerations} 

\subsection{Aims}

One of the primary aims of this project will be to implement a compiler for the language given in section~\ref{sec:grammar}. This language is a modified subset of the C language, that contains only the bare bones needed to perform the buffer overflow exploit to begin ROPing.
\\
\\
An additional aim for this project will be to target the x86-64 assembly language for the compiler output. This architecture is chosen since it is the easiest to perform ROP exploits on. This is due to the fact that boundaries on instruction sizes aren't enforce like they are in other architectures such as MIPS.
\\
\\
A final aim for this project is to target the exploit to run on a virtualised Linux distro. Initially this distro will have defenses such as ASLR disabled, but as the project progresses the aim is to ultimately run the ROP exploit with the defenses in place. However, this is relegated to the extensions phase of the project as one of the first to be attempted.

\subsection{Objectives}


\subsection{Motivation}

% Compilers are hard things and it adds extra difficulty to project that otherwise would be simple
% Building my own compiler allows greater control of the low level

\subsection{Project Relevance} % Why is it important

% Compilers 

\section{Professional and Ethical Considerations}

\section{Related Work}

% Original paper
% ROP compiler github (more like a rop assembler) will be attempting something like this in extension if possible

\section{Requirements Analysis}

\newpage

\section{Appendix}

\subsection{Project Plan}

\newpage

\subsection{EBNF Grammar} \label{sec:grammar}
\textbf{Main things to note:} 
\begin{enumerate}
\item This language explicitly differentiates between arrays on the stack and ones on the heap.
\item The new and free keywords break from C convention so as not to mislead about malloc usage.
\item This language has the idiom declarations before definitions baked in. This is done for ease of type checking.
\item The precedence of operators is follows those in regular C.
\end{enumerate}
\textbf{Language:} 
\begin{grammar}
<Goal> ::= <FunctionDeclaration>* <MainFunction> <FunctionDefinition>*

<FunctionSignature> ::= <SignatureType> <Identifier> `(' (<SignatureType> <Identifier> (`,' <SignatureType> <Identifier>)*)? `)'

<FunctionDeclaration> ::= <FunctionSignature> `;'

<FunctionDefinition> ::= <FunctionSignature> `\{' <FunctionBody> `\}'

<FunctionBody> ::= <VarDeclaration>* <Statement>* `return' <Expression> `;'

<MainFunction> ::= `int' `main' `(' `int' <Identifier> `,' `char' `[' `]' `[' `]' <Identifier> `)' `\{' <FunctionBody> `\}'

<VarDeclaration> ::= <Type> <Identifier> `;'

<Type> ::= <StackArray> 
\alt <HeapArray> 
\alt <PrimitiveType>

<SignatureType> ::= <PrimitiveType>
\alt <HeapArray>

<PrimitiveType> ::= `int'
\alt `char'
\alt `boolean'

<StackArray> ::= `int' `[' <IntegerLiteral> `]'
\alt `char' `[' <IntegerLiteral> `]' 

<HeapArray> ::= `int' `[' `]'
\alt `char' `[' `]' 

<Statement> ::= `\{' <Statement>* `\}'
\alt `if' `(' <Expression> `)' <Statement> `else' <Statement>
\alt `while' `(' <Expression> `)' <Statement>
\alt <Identifier> `=' <Expression> `;'
\alt <Identifier> `[' <Expression> `]' `=' <Expression> `;'
\alt `free' <Identifier> `;'
\alt `print' `(' <Expression> `)' `;'

<Expression> ::= <Expression> (`\&\&' | `||' | `!=' | `==' | `<' | `<=' | `>' | `>=' | `+' | `-' | `*') <Expression>
\alt <Expression> `[' <Expression> `]'
\alt <Identifier>  `(' (<Expression> (`,' <Expression>)*)? `)'
\alt <IntegerLiteral>
\alt <CharacterLiteral>
\alt <BooleanLiteral>
\alt <Identifier>
\alt `new' `int' `[' <Expression> `]'
\alt `new' `char' `[' <Expression> `]'
\alt `!' <Expression>
\alt `(' <Expression> `)'
\end{grammar}
\newpage

\subsection{Example Program}
\lstinputlisting{Factorial.rop}
\newpage

\subsection{Proposal}

\newpage
\bibliographystyle{plain}
\bibliography{InterimReport}

\end{document}